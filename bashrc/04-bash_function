#!/usr/bin/env bash

tabname() {
    echo -en "\033]0;$*\a"
}

find_bin_dirs() {
    find "$1" -maxdepth 2 -follow -not -path '*/\.*' -type d -name bin -printf "%p:"
}

killemall() {
    if [ -z "$1" ]; then
        echo "pattern argument required" 1>&2
        return 1
    fi
    kill -9 $(pgrep -fi "$1")
}

highlight() {
    # cat <file> | highlight foo
    # cat <file> | highlight "foo\|bar"
    # cat <file> | highlight "foo\|bar" | less -r
    COLOR=31
    PATTERN="$1"
    ESCAPE=$(printf "\033')
    sed "s,${PATTERN},${ESCAPE}[${COLOR}m&${ESCAPE}[0m,g"
}

# kubectl
if command -v kubectl >/dev/null 2>&1; then

    # description:
    #   show logs of the running pod that matches the pattern
    # arguments:
    #   pattern - pod name pattern
    # usage:
    #   kctl_log <pattern>
    #   e.g.: kctl_log foo
    kctl_log() {
        if [ -z "$1" ]; then
            echo "pod name pattern argument required" 1>&2;
            return 1
        fi
        kubectl logs -f $(kubectl get pods | grep -i running | grep "$1" | awk '{print $1}')
    }

    # description:
    #   show logs of the running pod that matches the pattern, in json format
    # arguments:
    #   pattern - pod name pattern
    # usage:
    #   kctl_log_json <pattern>
    #   e.g.: kctl_log_json foo
    kctl_log_json() {
        if [ -z "$1" ]; then
            echo "pod name pattern argument required" 1>&2
            return 1
        fi
        kubectl logs -f $(kubectl get pods | grep -i running | grep "$1" | awk '{print $1}') | grep '^{.*}$' | jq -r '.'
    }

    # delete all pods (optional: that match the pattern) with status different than running
    # arguments:
    #   optional: pattern - the pattern to match the pod name against
    # usage:
    #  kube_cleanup_pods [pattern]
    #  e.g.: kube_cleanup_pods
    kube_cleanup_pods() {
        if [ -n "$1" ]; then
            for p in $(kubectl get pods | tail -n +2 | grep -vi running | grep "$1" | awk '{print $1}'); do
                kubectl delete pod --grace-period=0 "$p"
            done
        else
            for p in $(kubectl get pods | tail -n +2 | grep -vi running | awk '{print $1}'); do
                kubectl delete pod --grace-period=0 "$p"
            done
        fi
    }

    # set up port-forwarding for service that matches the pattern (in a loop, to reconnect after timeout)
    # arguments:
    #   pattern - the pattern to match the service name against
    #   port-mapping - the port mapping to use
    # usage:
    #   kube_port_forward <pattern> <port-mapping>
    #   e.g.: kube_port_forward foo-service 8080:80
    kube_port_forward() {
        if [ -z "$1" ]; then
            echo "service name pattern argument required" 1>&2
            return 1
        fi
        if [ -z "$2" ]; then
            echo "port-mapping argument required" 1>&2
            return 1
        fi
        while true; do kubectl port-forward svc/$(kubectl get service | grep "$1" | awk '{print $1}') "$2"; done
    }

fi